# 一、判断对象是否存活
## 1、引用计数算法

- 给对象添加一个引用计数器，每当一个地方引用了该对象，计数器加1,；当引用失效，计数器减1.当计数器为0表示该对象已死，可回收。但是无法解决两个对象互相引用的情况
## 2、可达性分析算法

- 通过一系列称为的GC Roots对象为起点，从这些节点往下搜索，搜索走过的路径为引用链，当一个对象到GC Roots没有任何引用链相连是，即对象到GC Roots不可达，则证明对象已死，可回收
- 可作为GC Roots的对象包括：虚拟机栈中引用的对象，本地方法栈中Native方法引用的对象，方法区静态属引用的对象，方法区常量引用的对象
# 二、JVM垃圾回收原理
将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、。老年代的方式进行收集
# 三、垃圾收集算法

- 标记-清除算法
- 标记-整理算法
- 复制算法
- 分代收集算法

---

- 新生代：
   - 1、新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from；
   - 2、当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。
   - 3、复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。
- 老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。
- 持久代：持久代如果满了，将触发Full GC。
- 大对象直接进入老年代
- 长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。
# 四 什么情况下回出现Full GC，什么情况下会出现Young GC
## 对象优先在新生代Eden区中分配，如果Eden区没有足够的空间时，就会触发一次young gc
## Full gc的触发条件有多个，FULL GC的时候会STOP THE WORD

- 调用 System.gc()
- 老年代空间不足
- 空间分配担保失败

空间分配担保
在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。


# 五 GC对比
| 收集器 | 串行/并行/并发 | 新生代 | 老年代 | 目标 | 适用场景 |
| --- | --- | --- | --- | --- | --- |
| Serial | 串行 | 标记-复制 | 标记-整理 | 响应速度优先 | 单CPC模式下的Client |
| Parallel | 并行 | 标记-复制 | 标记-整理 | 吞吐量优先 | 在后台运算而不需要太多交互的任务 |
| CMS | 并发 | 标记-复制 | 标记-清除 | 响应速度优先 | 集中在互联网站上的Java应用 |
| G1 | 并发 | 标记-复制-整理 | 标记-复制-整理 | 响应速度优先 | 替换CMS |

- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。
##
## 1.CMS执行阶段
### 1.初始标记（STW）
标记GC roots
### 2.并发标记
标记所有存活对象
### 3.并发预清理
标记引用被改变的卡片
### 4.最终标记（STW）
最终标记存活对象
### 5.并发清除
删除不再使用的对象，并回收内存空间
### 6.并发重置
重置CMS内部算法参数，为下次做准备


# GC日志分析
### CMS
> [GC (Allocation Failure) [ParNew: 367523K->1293K(410432K), 0.0023988 secs] 522739K->156516K(1322496K), 0.0025301 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]

- **GC**：

表明进行了一次垃圾回收，前面没有Full修饰，表明这是一次Minor GC ,注意它不表示只GC新生代，并且现有的不管是新生代还是老年代都会STW。

- **Allocation Failure**：

表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。

- **ParNew**：

    表明本次GC发生在年轻代并且使用的是ParNew垃圾收集器。ParNew是一个Serial收集器的多线程版本，会使用多个CPU和线程完成垃圾收集工作（默认使用的线程数和CPU数相同，可以使用-XX：ParallelGCThreads参数限制）。该收集器采用复制算法回收内存，期间会停止其他工作线程，即Stop The World。

- **367523K->1293K(410432K)**：单位是KB

三个参数分别为：GC前该内存区域(这里是年轻代)使用容量，GC后该内存区域使用容量，该内存区域	总容量。

- **0.0023988 secs**：

    该内存区域GC耗时，单位是秒

- **522739K->156516K(1322496K)**：

三个参数分别为：堆区垃圾回收前的大小，堆区垃圾回收后的大小，堆区总大小。

- **0.0025301 secs**：

该内存区域GC耗时，单位是秒

- **[Times: user=0.04 sys=0.00, real=0.01 secs]**：

    分别表示用户态耗时，内核态耗时和总耗时
#### 分析下可以得出结论：
    该次GC新生代减少了367523-1293=366239K
    Heap区总共减少了522739-156516=366223K
    366239 – 366223 =16K，说明该次共有16K内存从年轻代移到了老年代，可以看出来数量并不多，说明都是生命周期短的对象，只是这种对象有很多。
    我们需要的是尽量避免Full GC的发生，让对象尽可能的在年轻代就回收掉，所以这里可以稍微增加一点年轻代的大小，让那17K的数据也保存在年轻代中。
